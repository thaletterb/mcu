/** nrf8001 example project 
 */

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#include "spi.h"
#include "hardware.h"

#include "hal_aci_tl.h"
#include "aci.h"
#include "aci_evts.h"
#include "aci_cmds.h"
#include "lib_aci.h"

#define W25Q_SS_PIN 1

#define LOGIC_LOW   0
#define LOGIC_HIGH  1

extern uint8_t rdynFlag;

/*  aci_struct that will contain:
*       total initial credits
*       current credit
*       current state of the aci (setup/standby/active/sleep)
*       open remote pipe pending
*       close remote pipe pending
*       Current pipe available bitmap
*       Current pipe closed bitmap
*       Current connection interval, slave latency and link supervision timeout
*       Current State of the the GATT client (Service Discovery)
*       Status of the bond (R) Peer address
*/
static struct aci_state_t aci_state;
static hal_aci_evt_t aci_data;
static hal_aci_data_t aci_cmd;

/** Function Prototypes **/
void resetDevice(void);

/** Scratch **/
///** Data type for ACI commands and events */
//typedef struct hal_aci_data_t{
//  uint8_t status_byte;
//  uint8_t buffer[HAL_ACI_MAX_LENGTH+1];
//} hal_aci_data_t;

//bool lib_aci_device_version()
//{
//  acil_encode_cmd_get_device_version(&(msg_to_send.buffer[0]));
//  return hal_aci_tl_send(&msg_to_send);
//}

//void acil_encode_cmd_get_device_version(uint8_t *buffer)
//{
//  *(buffer + OFFSET_ACI_CMD_T_LEN) = 1;
//  *(buffer + OFFSET_ACI_CMD_T_CMD_OPCODE) = ACI_CMD_GET_DEVICE_VERSION;
//}

/** End Scratch **/

#define OFFSET_ACI_CMD_T_LEN        0
#define OFFSET_ACI_CMD_T_CMD_OPCODE 1
#define ACI_CMD_GET_DEVICE_VERSION  0x09

hal_aci_data_t test_aci_command;

int main(void)
{
    SET_RSTN_HIGH();            // Set RST high
    // Init the device version aci command
    test_aci_command.buffer[OFFSET_ACI_CMD_T_LEN] = 1;
    test_aci_command.buffer[OFFSET_ACI_CMD_T_CMD_OPCODE] = ACI_CMD_GET_DEVICE_VERSION;

    //This will reset the nRF8001. ACI Device Started Event is generated by the nRF8001 device
    //as soon as the reset is complete
    hal_aci_tl_init();

    _delay_ms(100);
    //cli();
    sei();

    // Reset the device
    resetDevice();
    LED2_CONFIG_OUT;

    while(1){
        resetDevice();
        // Read the device started event
        if(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN)   // RDYN goes low when nrf8001 is ready
        {
            do
            {
                // Wait for nRF8001 to indicate it is ready by waiting for RDYN
                //_BIS_SR(LPM0_bits + GIE); // Enter LPM0 w/interrupt
                //_nop();
                asm volatile ("nop");
            }while(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN);
        }
        SET_REQN_LOW();     // Once nrf8001 signals ready, request data
        _delay_ms(2);
        spi_transmit(0x00);
        uint8_t packet_length = spi_transmit(0x00); // First byte of aci event is packet length
        for(uint8_t i=0; i<packet_length; i++)
        {
            spi_transmit(0x00);
        }
        SET_REQN_HIGH();    // End transmission
        _delay_ms(2);

        // Read the device version
        SET_REQN_LOW();
        if(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN)   // RDYN goes low when nrf8001 is ready
        {
            do
            {
                // Wait for nRF8001 to indicate it is ready by waiting for RDYN
                //_BIS_SR(LPM0_bits + GIE); // Enter LPM0 w/interrupt
                //_nop();
                asm volatile ("nop");
            }while(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN);
        }
        _delay_ms(2);
        spi_transmit(0x01);
        spi_transmit(0x09);
        SET_REQN_HIGH();

        if(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN)   // RDYN goes low when nrf8001 is ready
        {
            do
            {
                // Wait for nRF8001 to indicate it is ready by waiting for RDYN
                //_BIS_SR(LPM0_bits + GIE); // Enter LPM0 w/interrupt
                //_nop();
                asm volatile ("nop");
            }while(NRF8001_RDYN_PIN_INPUT_REG & NRF8001_RDYN_PIN);
        }
        _delay_ms(2);

        SET_REQN_LOW();
        _delay_ms(2);
        spi_transmit(0x00);
        packet_length = spi_transmit(0x00);
        for(uint8_t i=0; i<packet_length; i++)
        {
            spi_transmit(0x00);
        }
        SET_REQN_HIGH();
    }

    // Main application loop
    while(1)
    {
        if(rdynFlag == 1)
        {
            rdynFlag = 0;
            PORTB ^= (1<<LED1_PHYSICAL_PIN);
            m_rdy_line_handle();
        }

        // We enter the if statement only when there is a ACI event available to be processed
        if (lib_aci_event_get(&aci_state, &aci_data))
        {
            aci_evt_t * aci_evt;

            aci_evt = &aci_data.evt;
            switch(aci_evt->evt_opcode)
            {
                /**
                As soon as you reset the nRF8001 you will get an ACI Device Started Event
                */
                case ACI_EVT_DEVICE_STARTED:
                {

                  aci_state.data_credit_available = aci_evt->params.device_started.credit_available;
                  switch(aci_evt->params.device_started.device_mode)
                  {
                    case ACI_DEVICE_SETUP:
                        //P1OUT |= BIT0;                      // Turn on LED
                        LED2_CONFIG_OUT;
                        SET_LED2_HIGH();

                      /**
                      Device is in the setup mode
                      */
                      //Serial.println(F("Evt Device Started: Setup"));
                      aci_cmd.buffer[0] = 2;    //Length of ACI command
                      aci_cmd.buffer[1] = 0x01; //Command - Test
                      aci_cmd.buffer[2] = ACI_TEST_MODE_DTM_UART; //Command parameter
                      hal_aci_tl_send(&aci_cmd);
                      break;

                    case ACI_DEVICE_TEST:
                      //Serial.println(F("Evt Device Started: Test"));
                      //__no_operation();
                        asm volatile ("nop");

                      break;
                  }
                }
                break; //ACI Device Started Event

              case ACI_EVT_CMD_RSP:
                //If an ACI command response event comes with an error -> stop
                if (ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status)
                {
                  //ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
                  //TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
                  //all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command
                  //Serial.print(F("ACI Command "));
                  //Serial.println(aci_evt->params.cmd_rsp.cmd_opcode, HEX);
                  //Serial.println(F("Evt Cmd respone: Error. In an while(1); loop"));
                  while (1);
                }
                break;
            }
        }
        else
        {
            //Serial.println(F("No ACI Events available"));
            // No event in the ACI Event queue.
            // Arduino can go to sleep
            // Wakeup from sleep from the RDYN line
        }

        _delay_ms(10);
    }
    return 1;
}

/** @brief: resets the nrf8001 breakout
*/
void resetDevice(void)
{
    NRF8001_RSTN_CONFIG_OUT;    // Configure AVR PB0 as RST
    
    SET_RSTN_HIGH();            // Set RST high
    _delay_ms(50);               
    SET_RSTN_LOW();             // Set RST low
    _delay_ms(100);               
    SET_RSTN_HIGH();            // Set RST high
    _delay_ms(100);               
  
    SET_RSTN_HIGH();            // Set RST high
}
