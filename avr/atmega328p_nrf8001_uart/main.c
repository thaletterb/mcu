/** nrf8001 example project 
 */

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#include "spi.h"
#include "hardware.h"

#include "hal_aci_tl.h"
#include "aci.h"
#include "aci_evts.h"
#include "aci_cmds.h"
#include "lib_aci.h"

#define W25Q_SS_PIN 1

#define LOGIC_LOW   0
#define LOGIC_HIGH  1

extern uint8_t rdynFlag;

/*  aci_struct that will contain:
*       total initial credits
*       current credit
*       current state of the aci (setup/standby/active/sleep)
*       open remote pipe pending
*       close remote pipe pending
*       Current pipe available bitmap
*       Current pipe closed bitmap
*       Current connection interval, slave latency and link supervision timeout
*       Current State of the the GATT client (Service Discovery)
*       Status of the bond (R) Peer address
*/
static struct aci_state_t aci_state;
static hal_aci_evt_t aci_data;
static hal_aci_data_t aci_cmd;

/** Function Prototypes **/
void resetDevice(void);

int main(void)
{
    SET_RSTN_HIGH();            // Set RST high

    //This will reset the nRF8001. ACI Device Started Event is generated by the nRF8001 device
    //as soon as the reset is complete
    hal_aci_tl_init();

    _delay_ms(100);
    //cli();
    sei();

    // Reset the device
    resetDevice();
    LED2_CONFIG_OUT;

    _delay_ms(100);
    // Main application loop - never gets to here yet!!!!
    while(1)
    {
        if(rdynFlag == 1)
        {
            rdynFlag = 0;
            m_rdy_line_handle();
        }

        // We enter the if statement only when there is a ACI event available to be processed
        if (lib_aci_event_get(&aci_state, &aci_data))
        {
            aci_evt_t * aci_evt;

            aci_evt = &aci_data.evt;
            switch(aci_evt->evt_opcode)
            {
                /**
                As soon as you reset the nRF8001 you will get an ACI Device Started Event
                */
                case ACI_EVT_DEVICE_STARTED:
                {
                  PORTB |= (1<<LED1_PHYSICAL_PIN);

                  aci_state.data_credit_available = aci_evt->params.device_started.credit_available;
                  switch(aci_evt->params.device_started.device_mode)
                  {
                    case ACI_DEVICE_SETUP:
                        //P1OUT |= BIT0;                      // Turn on LED
                        LED2_CONFIG_OUT;
                        SET_LED2_HIGH();

                      /**
                      Device is in the setup mode
                      */
                      //Serial.println(F("Evt Device Started: Setup"));
                      aci_cmd.buffer[0] = 2;    //Length of ACI command
                      aci_cmd.buffer[1] = 0x01; //Command - Test
                      aci_cmd.buffer[2] = ACI_TEST_MODE_DTM_UART; //Command parameter
                      hal_aci_tl_send(&aci_cmd);
                      break;

                    case ACI_DEVICE_TEST:
                      //Serial.println(F("Evt Device Started: Test"));
                      //__no_operation();
                        asm volatile ("nop");

                      break;
                  }
                }
                break; //ACI Device Started Event

              case ACI_EVT_CMD_RSP:
                //If an ACI command response event comes with an error -> stop
                if (ACI_STATUS_SUCCESS != aci_evt->params.cmd_rsp.cmd_status)
                {
                  //ACI ReadDynamicData and ACI WriteDynamicData will have status codes of
                  //TRANSACTION_CONTINUE and TRANSACTION_COMPLETE
                  //all other ACI commands will have status code of ACI_STATUS_SCUCCESS for a successful command
                  //Serial.print(F("ACI Command "));
                  //Serial.println(aci_evt->params.cmd_rsp.cmd_opcode, HEX);
                  //Serial.println(F("Evt Cmd respone: Error. In an while(1); loop"));
                  while (1);
                }
                break;
            }
        }
        else
        {
            //Serial.println(F("No ACI Events available"));
            // No event in the ACI Event queue.
            // Arduino can go to sleep
            // Wakeup from sleep from the RDYN line
        }

        _delay_ms(10);
    }
    return 1;
}

/** @brief: resets the nrf8001 breakout
*/
void resetDevice(void)
{
    NRF8001_RSTN_CONFIG_OUT;    // Configure AVR PB0 as RST
    
    SET_RSTN_HIGH();            // Set RST high
    _delay_ms(50);               
    SET_RSTN_LOW();             // Set RST low
    _delay_ms(100);               
    SET_RSTN_HIGH();            // Set RST high
    _delay_ms(100);               
  
    SET_RSTN_HIGH();            // Set RST high
}
